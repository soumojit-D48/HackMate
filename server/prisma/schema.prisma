// // // This is your Prisma schema file,
// // // learn more about it in the docs: https://pris.ly/d/prisma-schema

// // // Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// // // Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// // generator client {
// //   provider = "prisma-client"
// //   output   = "../generated/prisma"
// // }

// // datasource db {
// //   provider = "postgresql"
// //   url      = env("DATABASE_URL")
// // }















// // Prisma Schema for Hackathon Team Finder
// // Database: PostgreSQL (via Supabase)

// generator client {
//   provider = "prisma-client-js"
// }

// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// // ============================================
// // USER & AUTHENTICATION
// // ============================================

// model User {
//   id            String    @id @default(uuid())
//   email         String    @unique
//   clerkId       String?   @unique // Clerk user ID for auth sync
//   username      String    @unique
//   fullName      String
//   bio           String?   @db.Text
//   profilePhoto  String?
//   resumeUrl     String?
//   location      String?
//   experience    Experience @default(BEGINNER)
  
//   // Skills as JSON array
//   skills        Json      @default("[]") // ["React", "Node.js", "Python"]
//   interests     Json      @default("[]") // ["AI/ML", "Web3", "FinTech"]
  
//   socialLinks   Json      @default("{}") // {"github": "url", "linkedin": "url"}
//   availability  Boolean   @default(true)
//   isActive      Boolean   @default(true)
//   role          UserRole  @default(INDIVIDUAL)
  
//   createdAt     DateTime  @default(now())
//   updatedAt     DateTime  @updatedAt
//   lastActive    DateTime  @default(now())
  
//   // Relations
//   ownedTeams    Team[]             @relation("TeamOwner")
//   teamMembers   TeamMember[]
//   teamRequests  TeamRequest[]
//   sentMessages  Message[]
//   notifications Notification[]
//   reports       Report[]           @relation("Reporter")
//   reportedBy    Report[]           @relation("Reported")
//   conversationParticipants ConversationParticipant[]
  
//   @@index([email])
//   @@index([username])
//   @@index([clerkId])
//   @@map("users")
// }

// enum Experience {
//   BEGINNER
//   INTERMEDIATE
//   ADVANCED
//   EXPERT
// }

// enum UserRole {
//   INDIVIDUAL    // Looking for a team
//   TEAM_LEADER   // Leading a team
//   BOTH          // Open to both
// }

// // ============================================
// // TEAMS
// // ============================================

// model Team {
//   id              String      @id @default(uuid())
//   name            String
//   description     String      @db.Text
//   tagline         String?
  
//   // Tech stack and requirements
//   techStack       Json        @default("[]") // ["React", "Node.js", "MongoDB"]
//   requiredRoles   Json        @default("[]") // [{"role": "Frontend Dev", "count": 2, "filled": 1}]
  
//   maxMembers      Int         @default(5)
//   currentMembers  Int         @default(1)
//   isOpen          Boolean     @default(true) // Accepting members
  
//   projectIdea     String?     @db.Text
//   hackathonName   String?
//   deadline        DateTime?
  
//   ownerId         String
//   owner           User        @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  
//   createdAt       DateTime    @default(now())
//   updatedAt       DateTime    @updatedAt
  
//   // Relations
//   members         TeamMember[]
//   requests        TeamRequest[]
//   messages        Message[]
  
//   @@index([ownerId])
//   @@index([isOpen])
//   @@index([createdAt])
//   @@map("teams")
//   conversations Conversation[]
// }

// // ============================================
// // TEAM MEMBERSHIP
// // ============================================

// model TeamMember {
//   id        String          @id @default(uuid())
//   teamId    String
//   userId    String
//   role      String          // "Frontend Dev", "Backend Dev", "Designer"
//   status    MemberStatus    @default(ACTIVE)
  
//   joinedAt  DateTime        @default(now())
  
//   team      Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)
//   user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
//   @@unique([teamId, userId])
//   @@index([teamId])
//   @@index([userId])
//   @@map("team_members")
// }

// enum MemberStatus {
//   ACTIVE
//   INACTIVE
//   LEFT
// }

// // ============================================
// // TEAM REQUESTS (Join/Invite)
// // ============================================

// model TeamRequest {
//   id          String        @id @default(uuid())
//   teamId      String
//   userId      String
//   type        RequestType   // INVITE or JOIN_REQUEST
//   status      RequestStatus @default(PENDING)
//   message     String?       @db.Text
  
//   createdAt   DateTime      @default(now())
//   respondedAt DateTime?
  
//   team        Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
//   user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
//   @@unique([teamId, userId, type]) // Prevent duplicate requests
//   @@index([teamId])
//   @@index([userId])
//   @@index([status])
//   @@map("team_requests")
// }

// enum RequestType {
//   INVITE        // Team invites user
//   JOIN_REQUEST  // User requests to join
// }

// enum RequestStatus {
//   PENDING
//   ACCEPTED
//   REJECTED
//   CANCELLED
// }

// // ============================================
// // MESSAGING (Socket.io Real-time Chat)
// // ============================================

// // Conversations can be 1-to-1 (DM) or team-based (group chat)
// model Conversation {
//   id          String            @id @default(uuid())
//   type        ConversationType  @default(TEAM)
//   teamId      String?           @unique // For team chats
//   name        String?           // Custom name for group DMs
  
//   createdAt   DateTime          @default(now())
//   updatedAt   DateTime          @updatedAt
  
//   team        Team?             @relation(fields: [teamId], references: [id], onDelete: Cascade)
//   participants ConversationParticipant[]
//   messages    Message[]
  
//   @@index([teamId])
//   @@map("conversations")
// }

// enum ConversationType {
//   DIRECT      // 1-to-1 DM
//   TEAM        // Team group chat
//   GROUP       // Custom group chat
// }

// // Track who's in each conversation
// model ConversationParticipant {
//   id              String       @id @default(uuid())
//   conversationId  String
//   userId          String
  
//   // Last read tracking for unread count
//   lastReadAt      DateTime     @default(now())
//   joinedAt        DateTime     @default(now())
  
//   // Typing indicator timestamp
//   lastTypingAt    DateTime?
  
//   conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
//   user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
//   @@unique([conversationId, userId])
//   @@index([conversationId])
//   @@index([userId])
//   @@map("conversation_participants")
// }

// model Message {
//   id              String       @id @default(uuid())
//   conversationId  String
//   senderId        String
//   content         String       @db.Text
  
//   // Message type for different content
//   messageType     MessageType  @default(TEXT)
  
//   // File attachments (images, docs, etc)
//   attachments     Json         @default("[]") // [{"url": "...", "name": "file.pdf", "size": 1024}]
  
//   // Mentions in message
//   mentions        Json         @default("[]") // ["userId1", "userId2"]
  
//   // Reply/thread support
//   replyToId       String?
//   replyTo         Message?     @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
//   replies         Message[]    @relation("MessageReplies")
  
//   isEdited        Boolean      @default(false)
//   isDeleted       Boolean      @default(false)
//   deletedAt       DateTime?
  
//   // Read receipts (array of userIds who read this)
//   readBy          Json         @default("[]") // ["userId1", "userId2"]
  
//   createdAt       DateTime     @default(now())
//   updatedAt       DateTime     @updatedAt
  
//   conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
//   sender          User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
//   reactions       MessageReaction[]
  
//   @@index([conversationId, createdAt])
//   @@index([senderId])
//   @@index([replyToId])
//   @@map("messages")
//   teams Team[]
// }

// enum MessageType {
//   TEXT
//   IMAGE
//   FILE
//   SYSTEM      // "User joined", "User left", etc.
//   CODE        // Code snippets
//   LINK        // Rich link previews
// }

// // Emoji reactions on messages
// model MessageReaction {
//   id        String   @id @default(uuid())
//   messageId String
//   userId    String
//   emoji     String   // "üëç", "‚ù§Ô∏è", "üòÇ"
  
//   createdAt DateTime @default(now())
  
//   message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
//   @@unique([messageId, userId, emoji])
//   @@index([messageId])
//   @@map("message_reactions")
// }

// // ============================================
// // NOTIFICATIONS
// // ============================================

// model Notification {
//   id          String           @id @default(uuid())
//   userId      String
//   type        NotificationType
//   title       String
//   message     String
//   link        String?          // Link to team/profile/request
  
//   isRead      Boolean          @default(false)
//   createdAt   DateTime         @default(now())
  
//   user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
//   @@index([userId, isRead])
//   @@index([createdAt])
//   @@map("notifications")
// }

// enum NotificationType {
//   TEAM_INVITE
//   JOIN_REQUEST
//   REQUEST_ACCEPTED
//   REQUEST_REJECTED
//   NEW_MESSAGE
//   TEAM_FULL
//   MEMBER_LEFT
//   SYSTEM
// }

// // ============================================
// // ADMIN & MODERATION
// // ============================================

// model Report {
//   id          String      @id @default(uuid())
//   reporterId  String
//   reportedId  String      // User or Team ID
//   entityType  EntityType
//   reason      String
//   description String?     @db.Text
//   status      ReportStatus @default(PENDING)
  
//   createdAt   DateTime    @default(now())
//   resolvedAt  DateTime?
  
//   reporter    User        @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)
//   reported    User        @relation("Reported", fields: [reportedId], references: [id], onDelete: Cascade)
  
//   @@index([status])
//   @@index([reporterId])
//   @@index([reportedId])
//   @@map("reports")
// }

// enum EntityType {
//   USER
//   TEAM
//   MESSAGE
// }

// enum ReportStatus {
//   PENDING
//   REVIEWED
//   RESOLVED
//   DISMISSED
// }

// // ============================================
// // ANALYTICS & TRACKING (Optional)
// // ============================================

// model ActivityLog {
//   id        String   @id @default(uuid())
//   userId    String?
//   action    String   // "created_team", "joined_team", "sent_message"
//   metadata  Json     @default("{}")
  
//   createdAt DateTime @default(now())
  
//   @@index([userId])
//   @@index([createdAt])
//   @@map("activity_logs")
// }































// Prisma Schema for Hackathon Team Finder
// Database: PostgreSQL (via Supabase)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  clerkId       String?   @unique // Clerk user ID for auth sync
  username      String    @unique
  fullName      String
  bio           String?   @db.Text
  profilePhoto  String?
  resumeUrl     String?
  location      String?
  experience    Experience @default(BEGINNER)
  
  // Skills as JSON array
  skills        Json      @default("[]") // ["React", "Node.js", "Python"]
  interests     Json      @default("[]") // ["AI/ML", "Web3", "FinTech"]
  
  socialLinks   Json      @default("{}") // {"github": "url", "linkedin": "url"}
  availability  Boolean   @default(true)
  isActive      Boolean   @default(true)
  role          UserRole  @default(INDIVIDUAL)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastActive    DateTime  @default(now())
  
  // Relations
  ownedTeams               Team[]                      @relation("TeamOwner")
  teamMembers              TeamMember[]
  teamRequests             TeamRequest[]
  sentMessages             Message[]
  conversationParticipants ConversationParticipant[]
  notifications            Notification[]
  reports                  Report[]                    @relation("Reporter")
  reportedBy               Report[]                    @relation("Reported")
  
  @@index([email])
  @@index([username])
  @@index([clerkId])
  @@map("users")
}

enum Experience {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum UserRole {
  INDIVIDUAL    // Looking for a team
  TEAM_LEADER   // Leading a team
  BOTH          // Open to both
}

// ============================================
// TEAMS
// ============================================

model Team {
  id              String      @id @default(uuid())
  name            String
  description     String      @db.Text
  tagline         String?
  
  // Tech stack and requirements
  techStack       Json        @default("[]") // ["React", "Node.js", "MongoDB"]
  requiredRoles   Json        @default("[]") // [{"role": "Frontend Dev", "count": 2, "filled": 1}]
  
  maxMembers      Int         @default(5)
  currentMembers  Int         @default(1)
  isOpen          Boolean     @default(true) // Accepting members
  
  projectIdea     String?     @db.Text
  hackathonName   String
  mode            HackathonMode  @default(ONLINE)
  deadline        DateTime?
  
  ownerId         String
  owner           User        @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Relations
  members         TeamMember[]
  requests        TeamRequest[] 
  conversation    Conversation?    // Each team has ONE group chat
  
  @@index([ownerId])
  @@index([isOpen])
  @@index([createdAt])
  @@map("teams")
}

enum HackathonMode {
  ONLINE
  OFFLINE
}

// ============================================
// TEAM MEMBERSHIP
// ============================================

model TeamMember {
  id        String          @id @default(uuid())
  teamId    String
  userId    String
  role      String          // "Frontend Dev", "Backend Dev", "Designer"
  status    MemberStatus    @default(ACTIVE)
  
  joinedAt  DateTime        @default(now())
  
  team      Team            @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
  @@map("team_members")
}

enum MemberStatus {
  ACTIVE
  INACTIVE
  LEFT
}

// ============================================
// TEAM REQUESTS (Join/Invite)
// ============================================

model TeamRequest {
  id          String        @id @default(uuid())
  teamId      String
  userId      String
  type        RequestType   // INVITE or JOIN_REQUEST
  status      RequestStatus @default(PENDING)
  message     String?       @db.Text
  
  createdAt   DateTime      @default(now())
  respondedAt DateTime?
  
  team        Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId, type]) // Prevent duplicate requests
  @@index([teamId])
  @@index([userId])
  @@index([status])
  @@map("team_requests")
}

enum RequestType {
  INVITE        // Team invites user
  JOIN_REQUEST  // User requests to join
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

// ============================================
// MESSAGING (Socket.io Real-time Chat)
// ============================================

// Conversations can be 1-to-1 (DM) or team-based (group chat)
model Conversation {
  id          String            @id @default(uuid())
  type        ConversationType  @default(TEAM)
  teamId      String?           @unique // For team chats
  name        String?           // Custom name for group DMs
  
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  
  team        Team?             @relation(fields: [teamId], references: [id], onDelete: Cascade)
  participants ConversationParticipant[]
  messages    Message[]
  
  @@index([teamId])
  @@map("conversations")
}

enum ConversationType {
  DIRECT      // 1-to-1 DM
  TEAM        // Team group chat
  GROUP       // Custom group chat
}

// Track who's in each conversation
model ConversationParticipant {
  id              String       @id @default(uuid())
  conversationId  String
  userId          String
  
  // Last read tracking for unread count
  lastReadAt      DateTime     @default(now())
  joinedAt        DateTime     @default(now())
  
  // Typing indicator timestamp
  lastTypingAt    DateTime?
  
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id              String       @id @default(uuid())
  conversationId  String
  senderId        String
  content         String       @db.Text
  
  // Message type for different content
  messageType     MessageType  @default(TEXT)
  
  // File attachments (images, docs, etc)
  attachments     Json         @default("[]") // [{"url": "...", "name": "file.pdf", "size": 1024}]
  
  // Mentions in message
  mentions        Json         @default("[]") // ["userId1", "userId2"]
  
  // Reply/thread support
  replyToId       String?
  replyTo         Message?     @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies         Message[]    @relation("MessageReplies")
  
  isEdited        Boolean      @default(false)
  isDeleted       Boolean      @default(false)
  deletedAt       DateTime?
  
  // Read receipts (array of userIds who read this)
  readBy          Json         @default("[]") // ["userId1", "userId2"]
  
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender          User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reactions       MessageReaction[]
  
  @@index([conversationId, createdAt])
  @@index([senderId])
  @@index([replyToId])
  @@map("messages")
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM      // "User joined", "User left", etc.
  CODE        // Code snippets
  LINK        // Rich link previews
}

// Emoji reactions on messages
model MessageReaction {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  emoji     String   // "üëç", "‚ù§Ô∏è", "üòÇ"
  
  createdAt DateTime @default(now())
  
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@map("message_reactions")
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id          String           @id @default(uuid())
  userId      String
  type        NotificationType
  title       String
  message     String
  link        String?          // Link to team/profile/request
  
  isRead      Boolean          @default(false)
  createdAt   DateTime         @default(now())
  
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  TEAM_INVITE
  JOIN_REQUEST
  REQUEST_ACCEPTED
  REQUEST_REJECTED
  NEW_MESSAGE
  TEAM_FULL
  MEMBER_LEFT
  SYSTEM
}

// ============================================
// ADMIN & MODERATION
// ============================================

model Report {
  id          String      @id @default(uuid())
  reporterId  String
  reportedId  String      // User or Team ID
  entityType  EntityType
  reason      String
  description String?     @db.Text
  status      ReportStatus @default(PENDING)
  
  createdAt   DateTime    @default(now())
  resolvedAt  DateTime?
  
  reporter    User        @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reported    User        @relation("Reported", fields: [reportedId], references: [id], onDelete: Cascade)
  
  @@index([status])
  @@index([reporterId])
  @@index([reportedId])
  @@map("reports")
}

enum EntityType {
  USER
  TEAM
  MESSAGE
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

// ============================================
// ANALYTICS & TRACKING (Optional)
// ============================================

model ActivityLog {
  id        String   @id @default(uuid())
  userId    String?
  action    String   // "created_team", "joined_team", "sent_message"
  metadata  Json     @default("{}")
  
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
  @@map("activity_logs")
}